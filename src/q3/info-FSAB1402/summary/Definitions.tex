\part{Définitions}

\begin{itemize}
  \item \textbf{\textit{Identificateur}} :

    Nom introduit sur le clavier. Commence avec une majuscule.

  \item \textbf{\textit{Variable en mémoire}} :

    Partie de la mémoire dans le système, caché au programmeur. Représenté avec des minuscules.

  \item \textbf{\textit{Environnement}} :

    Fonction qui prend un identificateur et renvoie une variable. Il fait correspondre chaque identificateur à une variable en mémoire (et sa valeur). Un même identificateur peut correspondre à différentes variables en différents endroits du programme.

  \item \textbf{\textit{Portée lexicale}} :

    Partie d'un programme pour laquelle l'identificateur correspond à la même variable en mémoire.

  \item \textbf{\textit{Identificateur libre}} :

    C'est l'identificateur compris dans l'environnement contextuel d'une procédure, c'est-à-dire les identificateurs qui ne sont pas dans la définition de la procédure et qui ne sont pas déclarés dans la procédure.

  \item \textbf{\textit{Invariant}} :

    C'est une formule logique qui est vraie à chaque appel récursif. Il contient des informations globales (qui ne changent pas avec l'exécution ($n$)) et locales (qui changent à chaque appel ($i$ et $a$)).
    Exemple : fonction qui calcule la n$^{\textrm{eme}}$ puissance de $x$. Un invariant est $x^n = x^ia$.

  \item \textbf{\textit{Accumulateur}} :

    Se référer au principe des vases communiquant. Dans l'exemple précédent, l'accumulateur est $a$.

  \item \textbf{\textit{Récursion terminale}} :

    Une fonction est récursive terminale, si l'appel récursif est la dernière instruction à exécuter dans le corps de la fonction. Ainsi la taille de la pile d'instruction (cfr Sémantique) reste constante au fil des appels récursifs.

  \item \textbf{\textit{Spécification}} :

    C'est une formule mathématique, ça n'a rien à voir avec le langage de programmation.
    Exemple : définition de $x^n$. $x^0=1$; $x^{2n+1}=x\cdot x^{2n}$; $x^{2n} = (x^n)^2$.

  \item \textbf{\textit{Liste}} :

    Structure composée soit d'une liste vide (\verb$nil$), soit d'un élément suivi d'une autre liste.

  \item \textbf{\textit{Pattern matching}} :

    C'est la correspondance des formes. Il s'agit d'une succession de clauses. Une clause est exécutée, si la forme de l'élément dans l'instruction \verb$case$ correspond à ce qui est compris dans la clause. La forme correspond si l'étiquette (label) et les arguments correspondent. Si c'est le cas, les identificateurs de la forme sont affectés aux parties correspondantes. Les clauses sont testées dans l'ordre textuel. La première à correspondre est exécutée et pas les autres.

  \item \textbf{\textit{Tuple}} :

    Structure composée d'une étiquette (label) et d'un nombre fini de champs. Les champs sont numérotés à partir de 1.

  \item \textbf{\textit{Enregistrement ou Record}} :

    Semblable à un Tuple, mais dont on peut définir le nom des champs. Les champs dont on n'a pas défini le nom sont numérotés à partir de 1. Deux champs ne peuvent pas avoir le même nom.

    Liste $\subset$ Tuple $\subset$ Record

  \item \textbf{\textit{Arbre}} :

    Il s'agit soit d'un nœud (Record) ou d'une feuille (\verb$leaf$). Chaque nœud comporte un ou plusieurs sous arbres (branches). Un arbre binaire est un arbre dont chaque nœud a deux branches. Un arbre est ordonné si, pour chaque nœud, la clé de leurs sous arbres de gauche (resp. droite) sont inférieures (supérieures) à la clé du nœud.

  \item \textbf{\textit{Sémantique}} :

    C'est ce que fait l'implémentation du langage de l'ordinateur. Il s'agit du modèle précis de l'exécution du langage de programmation. On l'utilise pour vérifier que le programme répond bien aux spécifications (souvent par preuve inductive).

  \item \textbf{\textit{Machine abstraite}} :

    Construction mathématique qui modélise l'exécution (ce sont les concepts utilisés pour effectuer la sémantique sur un programme).
    \begin{itemize}
      \item mémoire à affectation unique : variable et valeur (la valeur d'une variable ne change pas) 
        $\sigma = \{ x=10, y=2, c=\xi\}$

      \item mémoire à affectation multiple : contenu des cellules
        $\sigma' = \{c:x\}$

      \item environnement : 
        $E= \{ X\rightarrow x, Y \rightarrow y\}$

      \item instruction sémantique : instruction + son environnement 
        $(<s>,E)$

      \item pile sémantique : pile d'instructions sémantiques ST 
        $=[(<s_1>,E_1),...,(<s_n>,E_n)]$

      \item exécution : séquence d'états d'exécution
        (ST1,$\sigma_1$)$\rightarrow$(ST2,$\sigma_2$)$\rightarrow$ $...$ $\rightarrow$(STN,$\sigma_n$)
    \end{itemize}

  \item \textbf{\textit{Quelques règles de sémantique}} :

    Etat initial : ST0 $=([(<s>,E=\emptyset)],\sigma_0=\emptyset)$

    A la fin : STN $=([],\sigma_n)$

    Environnement : adjonction $E_2 = E_1 \cup \{X\rightarrow x\}$
    sauf pour les appels de fonction : restriction à l'environnement contextuel.

    Composition séquentielle : $([(<s>,E)],\sigma) \rightarrow ([(<s_1>,E),(<s_2>,E)],\sigma)$

    Procédure en mémoire : p = (\verb$proc($\$ \verb$X1 X2 ...) <s> end$, CE)

  \item \textbf{\textit{Argument formel}} :

    Arguments dans la définition d'une procédure. Exemple : \verb$P = proc($\$ \verb$X1 X2)$ \verb$X1$ et \verb$X2$ sont des arguments formels.

  \item \textbf{\textit{Environnement contextuel}} :
    Environnement propre à une certaine procédure. Il fait le lien entre, uniquement, les identificateurs libres et leur variable en mémoire.

  \item \textbf{\textit{Cellule}} :

    C'est un conteneur avec une identité constante et un contenu variable. L'identité est le nom ou adresse de la cellule. Le contenu est associé à une variable qui est constante, mais la variable peut être remplacée par une autre. Il y a égalité entre deux cellules si ce sont les mêmes.

    Exemple : $\sigma = \{ x=10 c=\xi\}$ et $\sigma' = \{c:x\}$
    Nous avons que $\xi$ est l'identité de \verb$C$, son contenu est $x$.

    En langage noyau, la construction d'une cellule est de la manière suivante : \verb${NewCell I C}$ ($\Leftrightarrow$ \verb${NewCell I}$)

  \item \textbf{\textit{Encapsulation}} : 

    A compléter.

  \item \textbf{\textit{Abstraction}} :

    A compléter.

  \item \textbf{\textit{Polymorphisme}} :

    Une méthode est polymorphe si elle peut prendre des arguments différents et faire la même chose dans chacun des cas. Une telle méthode est reprise dans la définition d'une interface en java.

  \item \textbf{\textit{Héritage}} :

    Lorsqu'une classe A hérite d'une classe B, A prend la définition de B comme base (méthodes et ?) et peut modifier les méthodes ou en additionner.

  \item \textbf{\textit{Super-Classe}} :

    B est une super-classe de A si B est dans la déclaration \verb$from$ de A ou est une super-classe d'une classe qui est dans la déclaration \verb$from$ de A.

  \item \textbf{\textit{Objet}} :

    Ensemble des procédures visibles (\verb$methode$) qui ont accès à un état caché dans une cellule (\verb$attribut$).

  \item \textbf{\textit{Classe}} :

    Séparation entre définition d'objet et création.

  \item \textbf{\textit{Lien Dynamique}} :

    \verb$self$ A utiliser par défaut, fait référence à l'objet qui appelle la méthode.

  \item \textbf{\textit{Lien Statique}} :

    \verb$SuperClasse,methode$ Fait appel à la méthode décrite dans la SuperClasse. A utiliser uniquement pour la redéfinition d'une méthode déjà définie dans une super-classe.

  \item \textbf{\textit{Concurrence}} :

    Exécution de plusieurs activités au même temps. Elles peuvent communiquer (passer des informations de l'une à l'autre) et synchroniser (une activité attend une autre).

  \item \textbf{\textit{Exécution en Dataflow}} :

    Si on utilise une variable non initialisée, l'exécution attend qu'elle le soit. \verb$Browse$ utilise un \verb$thread$, il actualise l'affichage quand un identificateur est lié.

  \item \textbf{\textit{Fil Thread}} :

    C'est une activité, une séquence d'instructions en exécution. Chaque fil est indépendant des autres, c'est-à-dire qu'il n'y a pas d'ordre entre eux. Deux fils communiquent s'ils partagent les mêmes variables.

  \item \textbf{\textit{Ordre total}} :

    Tous les états d'exécution d'un même fil font un ordre total. Dans un programme séquentiel (non concurrent), il existe un seul fil, l'ordre total décrit l'ordre entre chaque paire d'états.

  \item \textbf{\textit{Ordre partiel}} :

    Les états d'exécution du programme complet (s'il est concurrent) sont dans un ordre partiel. On ne connaît pas l'ordre d'exécution entre un état d'un fil et un autre d'un autre fil, ce pour chaque paire d'états du programme.

  \item \textbf{\textit{Non déterminisme}} :

    Ça apparait lorsqu'on utilise la concurrence avec les cellules. Absolument à éviter à cause de l'ordre partiel. Un programme concurrent est non déterministe si le résultat final n'est pas déterministe.

  \item \textbf{\textit{Flot}} :

    C'est une liste dont l'extrémité est une variable non liée. Ça sert comme canal de communication entre deux fils (agents).

  \item \textbf{\textit{Agent}} :

    Activité concurrente qui utilise un ou plusieurs canaux de communication (flots).

  \item \textbf{\textit{Producteur}} : 

    Agent qui génère un flot de données. (Fonction utile : \verb${Delay 1000}$ met l'exécution en pause pendant une seconde).

  \item \textbf{\textit{Consommateur}} : 

    Agent qui lit un flot de données. Généralement les affichent.

\end{itemize}

\end{document}
