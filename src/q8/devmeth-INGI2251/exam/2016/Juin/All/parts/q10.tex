\clearpage{}
\section{Define program design. Describe modularity in terms of coupling
and cohesion. Discuss incremental development based on the uses graph.
Discuss information hiding, abstraction and generality.}

\subsection{Program design}

We focus here on how each software unit will be built. It is a basis for writing the code. \newline

We use the term software unit when we want to talk about a systemâ€™s composite parts
without being precise about what type of part (Library, module, class, package, etc.).

\subsection{Modularity}

$\rightarrow$ Keeping unrelated concerns of a system in separate modules (i.e.\ one concern = one
module). \newline

We can measure the separation of concerns in terms of coupling and cohesion. \newline

\subsubsection{Coupling}

The degree of interdependence between modules (the less, the better).

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.7\linewidth]{coupling.png}
\end{figure}
\FloatBarrier{}

Types of coupling:
\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.4\linewidth]{types_of_coupling.png}
\end{figure}
\FloatBarrier{}

There are different types of coupling (worse to best order):
\begin{itemize}
    \item Content: A branch into the code of B, method invocation
    \item Common: A and B share common data, public variable
    \item Control: A controls the behaviour of B, \todo[inline]{???}
    \item Stamp: A pass data structure to B, they are to agree on format
    \item Data: A pass simple data to B, only necessary data, an integer via parameter
\end{itemize}

\subsubsection{Cohesion}

The dependence among a module's internal elements (the more, the better). \newline

Types of cohesion:

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.4\linewidth]{types_of_cohesion.png}
\end{figure}

Different types of cohesion (worst to best order):

\begin{itemize}
\item Coincidental: parts are unrelated
\item Logical: parts related by the logic structure of the code (eg. Common code but
unrelated functions)
\item Temporal: parts are used in the same time in an execution
\item Procedural: parts belong to a common procedure (temporal + common purpose)
\item Communication: parts operate on the same data set
\item Functional (best): all and only parts essential to a single function
\item Informational: all and only parts essential to a single abstraction
\end{itemize}

\subsection{Incremental development based on the use graph}

The goal is to implement and test incrementally (i.e.\ identify progressively larger sets of
units). To do that, we need to know the dependencies between units $\rightarrow$ use graph. \newline

\begin{figure}[!ht]
    \begin{minipage}{\linewidth}
        \begin{minipage}{0.45\linewidth}
            \includegraphics[width=0.6\linewidth]{use_graph_1.png}
        \end{minipage}
        \begin{minipage}{0.45\linewidth}
            Nodes = software units \newline
            Edges = \enquote{uses}
        \end{minipage}
    \end{minipage}
\end{figure}

Fan-in: the number of units that use a particular unit. \newline
Fan-out: the number of units used by a particular unit. \newline
Goal: high fan-in, low fan-out. \newline

Cycles in uses graph = mutual dependency $\rightarrow$ Sandwiching: decomposing a unit into two units

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.8\linewidth]{use_graph_2.png}
\end{figure}

\subsection{Information hiding}

Each design decision is hidden inside a software unit = encapsulation.
Information hiding helps cohesion (hide data representation, hide an algorithm) and reduce coupling. \newline

In OO design, an object is abstract type that hides data representation. Objects cannot be totally uncoupled.

\subsection{Abstraction}
Omitting some details (e.g.\ pseudo-code vs.\ full code (with some non-pertinent aspect about the algorithm)). \newline

Different kinds of details:

\begin{itemize}
\item Decomposition hierarchy => abstract from internal structure
\item Interface specification => abstract from internal design details
\item Architectural views => abstract on one particular aspect
\item Virtual machine (layer) => abstract from lower level machine (layer)
\end{itemize}

\subsection{Generality}

Make a software unit as universally applicable as possible. \newline

Several ways of doing this:

\begin{itemize}
\item Parameterizing context-specific information => reuse by changing parameters
instead of code
\item Removing pre-conditions => less conditions for reuse
\item Simplifying post-conditions => decompose into simpler units, more broadly reusable
\end{itemize}
